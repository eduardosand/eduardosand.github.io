<!DOCTYPE html>
<html lang="en">
<head>
    <title>Eduardo Sandoval | Neuroscience PhD Candidate</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        /* Three.js canvas fills the screen */
        canvas {
            display: block;
        }

        /* Info Overlay */
        #info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem 2rem;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .name-block {
            pointer-events: auto;
        }

        .name {
            font-family: 'Instrument Serif', serif;
            font-size: clamp(2rem, 5vw, 3.5rem);
            color: #fff;
            font-weight: 400;
            letter-spacing: -0.02em;
            line-height: 1;
            margin-bottom: 0.4rem;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.8);
        }

        .tagline {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .nav-links {
            display: flex;
            gap: 0.5rem;
            pointer-events: auto;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .nav-links a:hover {
            color: #fff;
            border-color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .footer {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .bio {
            max-width: 450px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bio p {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.7;
            margin-bottom: 1rem;
        }

        .bio-links {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .bio-links a {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            color: #fff;
            text-decoration: none;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 0.6rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .bio-links a:hover {
            background: #fff;
            color: #000;
        }

        .bio-links a svg {
            width: 12px;
            height: 12px;
        }

        .stats {
            text-align: right;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 1rem 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            margin-bottom: 0.75rem;
        }

        .stat-item:last-child {
            margin-bottom: 0;
        }

        .stat-value {
            font-family: 'Instrument Serif', serif;
            font-size: 1.75rem;
            color: #fff;
        }

        .stat-label {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        /* Hint */
        .hint {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            pointer-events: none;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.6s ease, visibility 0.6s ease;
        }

        #loading.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader-text {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        .loader-bar {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            margin-top: 1rem;
            overflow: hidden;
        }

        .loader-progress {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Mobile */
        @media (max-width: 768px) {
            #info-overlay {
                padding: 1rem;
            }

            .header {
                flex-direction: column;
            }

            .footer {
                flex-direction: column;
            }

            .stats {
                text-align: left;
            }

            .bio {
                max-width: 100%;
            }
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader-text">Generating neural mesh...</div>
        <div class="loader-bar">
            <div class="loader-progress" id="loader-progress"></div>
        </div>
    </div>

    <!-- Info Overlay -->
    <div id="info-overlay">
        <div class="header">
            <div class="name-block">
                <h1 class="name">Eduardo Sandoval</h1>
                <p class="tagline">Neuroscience × Statistical Mechanics</p>
            </div>
            <nav class="nav-links">
                <a href="#" id="cv-link">CV</a>
                <a href="https://scholar.google.com/" target="_blank">Publications</a>
                <a href="https://github.com/eduardosand" target="_blank">GitHub</a>
                <a href="mailto:your.email@berkeley.edu">Contact</a>
            </nav>
        </div>

        <div class="footer">
            <div class="bio">
                <p>
                    PhD candidate at UC Berkeley in Neuroscience. My research applies 
                    statistical mechanics to experimental neuroscience, working primarily 
                    with human intracranial data and simulated neural networks.
                </p>
                <div class="bio-links">
                    <a href="https://eduardosand.github.io/intracranial_ephys_utils/" target="_blank">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/>
                            <polyline points="13 2 13 9 20 9"/>
                        </svg>
                        Intracranial Ephys Utils
                    </a>
                    <a href="https://neuroscience.berkeley.edu/" target="_blank">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
                            <path d="M6 12v5c3 3 9 3 12 0v-5"/>
                        </svg>
                        Berkeley Neuroscience
                    </a>
                </div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="instance-count">0</div>
                    <div class="stat-label">Instances</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="geometry-count">0</div>
                    <div class="stat-label">Geometries</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="lod-count">0</div>
                    <div class="stat-label">LOD Levels</div>
                </div>
            </div>
        </div>
    </div>

    <div class="hint">Click + drag to explore • Hover to highlight</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",

                "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.0/build/index.module.js",

                "@three.ez/batched-mesh-extensions": "https://cdn.jsdelivr.net/npm/@three.ez/batched-mesh-extensions@0.0.8/build/webgl.js",
                "bvh.js": "https://cdn.jsdelivr.net/npm/bvh.js@0.0.13/build/index.js",

                "@three.ez/simplify-geometry": "https://cdn.jsdelivr.net/npm/@three.ez/simplify-geometry@0.0.1/build/index.js",
                "meshoptimizer": "https://cdn.jsdelivr.net/npm/meshoptimizer@0.23.0/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { MapControls } from 'three/addons/controls/MapControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { acceleratedRaycast, computeBatchedBoundsTree } from 'three-mesh-bvh';
        import { createRadixSort, extendBatchedMeshPrototype, getBatchedMeshLODCount } from '@three.ez/batched-mesh-extensions';
        import { performanceRangeLOD, simplifyGeometriesByErrorLOD } from '@three.ez/simplify-geometry';

        // Extend BatchedMesh prototype with new methods
        extendBatchedMeshPrototype();

        // Add accelerated raycasting from three-mesh-bvh
        THREE.Mesh.prototype.raycast = acceleratedRaycast;
        THREE.BatchedMesh.prototype.computeBoundsTree = computeBatchedBoundsTree;

        let camera, scene, renderer;

        // Configuration - adjust these values as needed
        const instancesCount = 10000;  // Reduced from 500k for better initial load
        const geometryCount = 10;
        const lodLevels = 5;

        let batchedMesh;
        let lastHoveredInstance = null;
        const lastHoveredColor = new THREE.Color();
        const highlight = new THREE.Color('white');  // Highlight color on hover

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(1, 1);
        const position = new THREE.Vector3();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3(1, 1, 1);
        const matrix = new THREE.Matrix4();
        const color = new THREE.Color();

        init();

        async function init() {
            updateProgress(10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.body.appendChild(renderer.domElement);

            updateProgress(20);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111118);

            // Environment map for nice reflections
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            updateProgress(30);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 80);

            // Raycaster optimization
            raycaster.firstHitOnly = true;

            // Controls - MapControls for the grid view
            const controls = new MapControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI / 2.1;  // Prevent going below ground
            controls.minDistance = 10;
            controls.maxDistance = 200;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            updateProgress(40);

            // Load pyramidal cell model
            const loader = new GLTFLoader();
            const gltf = await loader.loadAsync('models/hippocampus_ca1_pyramidal_cell.glb');

            // Extract geometry from the loaded model
            // Note: The structure depends on how the model was exported
            // We may need to traverse to find the geometry
            let pyramidalGeometry;
            gltf.scene.traverse((child) => {
                if (child.isMesh && !pyramidalGeometry) {
                    pyramidalGeometry = child.geometry;
                }
            });

            // Scale the geometry if needed (neurons can be very small or large)
            pyramidalGeometry.scale(0.25, 0.25, 0.25);  // Adjust this value as needed
            // Create geometries
            // These can later be replaced with pyramidal cell models
            const geometries = [
                pyramidalGeometry,
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 1, 1),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 1, 2),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 1, 3),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 1, 4),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 1, 5),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 2, 1),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 2, 3),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 3, 1),
                new THREE.TorusKnotGeometry(1, 0.4, 256, 32, 4, 1)
                // Extract just the geometry (ignoring materials, scene hierarchy, etc.)
            ];

            updateProgress(50);

            // Generate 4 LODs (levels of detail) for each geometry using meshoptimizer
            const geometriesLODArray = await simplifyGeometriesByErrorLOD(geometries, 4, performanceRangeLOD);

            updateProgress(70);

            // Create BatchedMesh with calculated buffer sizes
            const { vertexCount, indexCount, LODIndexCount } = getBatchedMeshLODCount(geometriesLODArray);
            
            batchedMesh = new THREE.BatchedMesh(
                instancesCount, 
                vertexCount, 
                indexCount, 
                new THREE.MeshStandardMaterial({ 
                    metalness: 0.9, 
                    roughness: 0.3
                })
            );

            // Enable radix sort for better performance
            batchedMesh.customSort = createRadixSort(batchedMesh);

            // Add geometries and their LODs to the batched mesh
            for (let i = 0; i < geometriesLODArray.length; i++) {
                const geometryLOD = geometriesLODArray[i];
                const geometryId = batchedMesh.addGeometry(geometryLOD[0], -1, LODIndexCount[i]);
                
                // Add LOD levels with increasing distances
                batchedMesh.addGeometryLOD(geometryId, geometryLOD[1], 50);
                batchedMesh.addGeometryLOD(geometryId, geometryLOD[2], 100);
                batchedMesh.addGeometryLOD(geometryId, geometryLOD[3], 125);
                batchedMesh.addGeometryLOD(geometryId, geometryLOD[4], 200);
            }

            updateProgress(80);

            // Place instances in a 2D grid with randomized rotation and color
            const sqrtCount = Math.ceil(Math.sqrt(instancesCount));
            const size = 5.5;  // Spacing between instances
            const start = (sqrtCount / -2 * size) + (size / 2);

            for (let i = 0; i < instancesCount; i++) {
                const row = Math.floor(i / sqrtCount);
                const col = i % sqrtCount;
                
                // Add instance with random geometry
                const id = batchedMesh.addInstance(Math.floor(Math.random() * geometriesLODArray.length));
                
                // Position in grid
                position.set(col * size + start, 0, row * size + start);
                
                // Random rotation
                quaternion.random();
                
                // Set transform
                batchedMesh.setMatrixAt(id, matrix.compose(position, quaternion, scale));
                
                // Random color (HSL for nice distribution)
                batchedMesh.setColorAt(id, color.setHSL(Math.random(), 0.7, 0.5));
            }

            updateProgress(90);

            // Compute BLAS (bottom-level acceleration structure) BVH using three-mesh-bvh
            batchedMesh.computeBoundsTree();

            // Compute TLAS (top-level acceleration structure) BVH using @three.ez/batched-mesh-extensions
            batchedMesh.computeBVH(THREE.WebGLCoordinateSystem);

            scene.add(batchedMesh);

            // Update stats display
            document.getElementById('instance-count').textContent = instancesCount.toLocaleString();
            document.getElementById('geometry-count').textContent = geometryCount;
            document.getElementById('lod-count').textContent = lodLevels;

            updateProgress(100);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);

            // Event listeners
            document.addEventListener('pointermove', onPointerMove);
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            renderer.setAnimationLoop(animate);
        }

        function updateProgress(percent) {
            document.getElementById('loader-progress').style.width = percent + '%';
        }

        function onPointerMove(event) {
            // Convert mouse position to normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycast();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function raycast() {
            raycaster.setFromCamera(mouse, camera);
            const intersection = raycaster.intersectObject(batchedMesh);

            const batchId = intersection.length > 0 ? intersection[0].batchId : null;

            // Skip if hovering same instance
            if (lastHoveredInstance === batchId) return;

            // Restore previous hovered instance color
            if (lastHoveredInstance !== null) {
                batchedMesh.setColorAt(lastHoveredInstance, lastHoveredColor);
            }

            // Highlight new hovered instance
            if (batchId !== null) {
                batchedMesh.getColorAt(batchId, lastHoveredColor);
                batchedMesh.setColorAt(batchId, highlight);
            }

            lastHoveredInstance = batchId;
        }

        function animate() {
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
